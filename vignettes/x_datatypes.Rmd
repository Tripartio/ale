---
title: "ale function handling of various datatypes for x"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ale function handling of various datatypes for x}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitr, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ale)
library(dplyr)
```

This vignette demonstrates how `ale` works for various datatypes of input (x) values. You should first read the [introductory vignette](intro.Rmd "Introduction to the ale package") that explains general functionality of the package; this vignette is a demonstration of specific functionality.

## Modified `mtcars` dataset (Motor Trend Car Road Tests)

For this demonstration, we will modify the built-in `mtcars` dataset so that it has binary (logical), multinomial (factor, that is, non-ordered categories), ordinal (ordered factor), discrete interval (integer), and continuous interval (numeric or double) values. This will let us test all the different basic variations of x variables.

### Original dataset

```{r mtcars, echo=TRUE}
help(mtcars)
```

#### Description

This is a transformation of the `mtcars` dataset from R to produce a small dataset with each of the fundamental datatypes: logical, factor, ordered, integer, and double. For the factor, it adds the country of the car manufacturer.

Here is the description of the `mtcars` dataset: The data was extracted from the 1974 *Motor Trend* US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973--74 models). 

#### Format

A tibble with 32 observations on 12 variables.

| Variable | Format  | Description                              |
|----------|---------|------------------------------------------|
| mpg      | double  | Miles/(US) gallon                        |
| cyl      | integer | Number of cylinders                      |
| disp     | double  | Displacement (cu.in.)                    |
| hp       | double  | Gross horsepower                         |
| drat     | double  | Rear axle ratio                          |
| wt       | double  | Weight (1000 lbs)                        |
| qsec     | double  | 1/4 mile time                            |
| vs       | logical | Engine (0 = V-shaped, 1 = straight)      |
| am       | logical | Transmission (0 = automatic, 1 = manual) |
| gear     | ordered | Number of forward gears                  |
| carb     | integer | Number of carburetors                    |
| country  | factor  | Country of car manufacturer              |

#### Note

Henderson and Velleman (1981) comment in a footnote to Table 1: 'Hocking [original transcriber]'s noncrucial coding of the Mazda's rotary engine as a straight six-cylinder engine and the Porsche's flat engine as a V engine, as well as the inclusion of the diesel Mercedes 240D, have been retained to enable direct comparisons to be made with previous analyses.'

#### Source

Henderson and Velleman (1981), Building multiple regression models interactively. *Biometrics*, **37**, 391--411.

### Modified version: `var_cars`

To get the multinomial variable, we will adapt information from the names of the cars which is available in the row names of the `mtcars` cases. However, since each is unique, we will determine the country of the manufacturer of each car; this gives us a factor of just six categories. With such a small dataset of only 32 rows, we cannot work with many more categories than that or else the models would end up with too many dummy variables for such a small dataset.

Our adapted dataset will be called `var_cars`; it is the same data as `mtcars` but with several variables encoded as more diverse yet appropriate datatypes.

```{r mtcars_to_cars}
# Create a function to determine the country of origin of a car based on its make
car_country <- function(make) {
  american_makes <- c("AMC", "Cadillac", "Camaro", "Chrysler", "Dodge", "Duster", "Ford", "Hornet", "Lincoln", "Pontiac", "Valiant")
  japanese_makes <- c("Datsun", "Honda", "Mazda", "Toyota")
  italian_makes <- c("Ferrari", "Fiat", "Maserati")
  british_makes <- c("Lotus")
  swedish_makes <- c("Volvo")
  german_makes <- c("Merc", "Porsche")
  
  case_when(
    make %in% american_makes ~ 'USA',
    make %in% japanese_makes ~ 'Japan',
    make %in% italian_makes ~ 'Italy',
    make %in% british_makes ~ 'UK',
    make %in% swedish_makes ~ 'Sweden',
    make %in% german_makes ~ 'Germany',
  )
}

var_cars <- 
  mtcars |> 
  as_tibble(rownames = 'make') |> 
  # retain only first word as the make without the car model
  mutate(
    make = stringr::str_extract(make, "^\\S+") |> factor(),
    country = car_country(make) |> factor()
    ) |> 
  select(-make) |> 
  mutate(across(c(vs, am), as.logical)) |> 
  mutate(gear = as.ordered(gear)) |> 
  mutate(across(c(cyl, carb), as.integer))

var_cars |> 
  print(n = 50)
```

```{r var_cars}
summary(var_cars)
```

## Modelling with ALE and GAM

With GAM, only numeric variables can be smoothed, not binary or categorical ones. However, smoothing does not always help improve the model since some variables are not related to the outcome and some that are related actually do have a simple linear relationship. To keep this demonstration simple, we have done some earlier analysis (not shown here) that determines where smoothing is worthwhile on the modified `var_cars` dataset, so only some of the numeric variables are smoothed. Our goal here is not to demonstrate the best modelling procedure but rather to demonstrate the flexibility of the `ale` package.

```{r cars_gam}
cm <- mgcv::gam(mpg ~ cyl + s(disp) + s(hp) + drat + wt + s(qsec) +
            + vs + am + gear + carb + country,
          data = var_cars)

summary(cm)
```

Now we generate ALE data from the `var_cars` GAM model and plot it.

```{r cars_ale, fig.asp=1.5}
cars_ale <- ale(var_cars, cm)

# Print all plots
gridExtra::grid.arrange(grobs = cars_ale$plots, ncol = 2)
```

We can see that `ale` has no trouble modelling any of the datatypes in our sample (logical, factor, ordered, integer, or double).

We can also generate and plot the ALE data for all two-way interactions.

```{r cars_ale_ixn, fig.asp=1.5}
cars_ale_ixn <- ale_ixn(var_cars, cm)

# Print plots
cars_ale_ixn$plots |>
  purrr::walk(\(.x1) {  # extract list of x1 ALE outputs
    gridExtra::grid.arrange(grobs = .x1, ncol = 2)  # plot all x1 plots
  })
```

There are no interactions in this dataset.

Finally, as explained in the vignette on modelling with [small datasets](small_datasets.Rmd "ale package for small datasets"), a more appropriate modelling workflow would require bootstrapping the entire model, not just the ALE data. So, let's do that now.

```{r cars_full, fig.asp=1.7}
mb <- model_bootstrap(
  var_cars, 
  'mgcv::gam(mpg ~ cyl + s(disp) + s(hp) + drat + wt + s(qsec) +
            + vs + am + gear + carb + country)'
)

gridExtra::grid.arrange(grobs = mb$ale$plots, ncol = 2)
```
